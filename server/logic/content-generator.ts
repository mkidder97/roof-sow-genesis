// SOW Content Generation Engine\nimport { ProjectInputs, SelectedSection } from './section-selector';\nimport { WindPressureResult } from './wind-pressure';\n\nexport interface GeneratedContent {\n  sectionId: string;\n  title: string;\n  content: string;\n  subsections?: {\n    title: string;\n    content: string;\n  }[];\n  formatting?: {\n    highlight?: boolean;\n    bold?: boolean;\n    indent?: boolean;\n  };\n}\n\nexport interface SOWDocument {\n  projectInfo: {\n    name: string;\n    address: string;\n    date: string;\n    templateType: string;\n  };\n  sections: GeneratedContent[];\n  metadata: {\n    totalPages: number;\n    wordCount: number;\n    completeness: number;\n    warnings: string[];\n  };\n}\n\nexport class SOWContentGenerator {\n  \n  /**\n   * Generates complete SOW document content\n   */\n  generateDocument(\n    projectInputs: ProjectInputs,\n    selectedSections: SelectedSection[],\n    windData?: WindPressureResult,\n    manufacturerData?: any\n  ): SOWDocument {\n    console.log(`📝 Generating SOW content for ${selectedSections.length} sections`);\n    \n    const sections: GeneratedContent[] = [];\n    const warnings: string[] = [];\n    \n    // Generate content for each selected section\n    for (const section of selectedSections) {\n      try {\n        const content = this.generateSectionContent(\n          section,\n          projectInputs,\n          windData,\n          manufacturerData\n        );\n        sections.push(content);\n      } catch (error) {\n        console.error(`❌ Failed to generate content for section ${section.id}:`, error);\n        warnings.push(`Failed to generate content for ${section.name}`);\n      }\n    }\n    \n    const wordCount = sections.reduce((total, section) => {\n      const sectionWords = section.content.split(/\\s+/).length;\n      const subsectionWords = section.subsections?.reduce((subTotal, sub) => \n        subTotal + sub.content.split(/\\s+/).length, 0) || 0;\n      return total + sectionWords + subsectionWords;\n    }, 0);\n    \n    const estimatedPages = Math.ceil(wordCount / 300); // ~300 words per page\n    \n    return {\n      projectInfo: {\n        name: this.extractProjectName(projectInputs),\n        address: projectInputs.address,\n        date: new Date().toLocaleDateString(),\n        templateType: section.variables?.templateType || 'Unknown'\n      },\n      sections,\n      metadata: {\n        totalPages: estimatedPages,\n        wordCount,\n        completeness: sections.length / selectedSections.length,\n        warnings\n      }\n    };\n  }\n  \n  /**\n   * Generates content for a specific section\n   */\n  private generateSectionContent(\n    section: SelectedSection,\n    inputs: ProjectInputs,\n    windData?: WindPressureResult,\n    manufacturerData?: any\n  ): GeneratedContent {\n    \n    switch (section.id) {\n      case 'project_scope':\n        return this.generateProjectScope(section, inputs);\n      case 'existing_conditions':\n        return this.generateExistingConditions(section, inputs);\n      case 'new_roof_system':\n        return this.generateNewRoofSystem(section, inputs);\n      case 'wind_uplift_requirements':\n        return this.generateWindUpliftRequirements(section, inputs, windData);\n      case 'fastening_specifications':\n        return this.generateFasteningSpecifications(section, inputs, windData, manufacturerData);\n      case 'flashings_and_accessories':\n        return this.generateFlashingsAndAccessories(section, inputs);\n      case 'drainage_systems':\n        return this.generateDrainageSystems(section, inputs);\n      case 'insulation_requirements':\n        return this.generateInsulationRequirements(section, inputs);\n      case 'vapor_barrier':\n        return this.generateVaporBarrier(section, inputs);\n      case 'walkway_pads':\n        return this.generateWalkwayPads(section, inputs);\n      case 'warranty_and_maintenance':\n        return this.generateWarrantyAndMaintenance(section, inputs);\n      default:\n        return this.generateGenericSection(section, inputs);\n    }\n  }\n  \n  private generateProjectScope(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    const sqft = inputs.square_footage.toLocaleString();\n    const projectType = inputs.project_type === 'tearoff' ? 'roof replacement' : 'roof recover';\n    \n    let buildingDescription = `This building`;\n    if (inputs.square_footage) {\n      buildingDescription += ` encompasses approximately ${sqft} total square feet`;\n    }\n    \n    const deckDescription = inputs.deck_type ? `The existing roof deck is ${inputs.deck_type.toLowerCase()}.` : '';\n    \n    let scopeDescription = '';\n    if (inputs.project_type === 'tearoff') {\n      scopeDescription = `The scope of work for this project is a **roof replacement**, including removal of all existing roof system materials down to the ${inputs.deck_type.toLowerCase()} roof deck and installation of new roof system`;\n    } else {\n      scopeDescription = `The scope of work for this project is a **roof recover**, including installation of new roof system over the existing roof assembly`;\n    }\n    \n    const systemDescription = this.buildSystemDescription(inputs);\n    \n    const content = `${buildingDescription}. ${deckDescription}\n\n${scopeDescription}, consisting of ${systemDescription}, including flashings, accessories and related work.\n\n• **The roof system specified herein is based on roof assembly wind uplift testing/approval for field of roof, with enhanced perimeter and corner attachment per this Scope of Work.**\n\n• **The Contractor will be responsible for providing any/all engineering services and documents required by the Authority Having Jurisdiction (AHJ), as required to obtain applicable permits and/or for project close-out. All required engineering services are to be performed by an engineer licensed in the appropriate State or as otherwise acceptable to the AHJ.**`;\n    \n    return {\n      sectionId: section.id,\n      title: 'SCOPE OF WORK',\n      content,\n      formatting: { highlight: true }\n    };\n  }\n  \n  private generateExistingConditions(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    let content = `**EXISTING CONDITIONS**\\n\\n`;\n    \n    content += `The existing roof assembly consists of:`;\n    \n    if (inputs.existing_membrane_type) {\n      content += `\\n• ${inputs.existing_membrane_type} membrane`;\n    }\n    \n    if (inputs.insulation_type && inputs.insulation_condition) {\n      content += `\\n• ${inputs.insulation_type} insulation (condition: ${inputs.insulation_condition})`;\n    }\n    \n    content += `\\n• ${inputs.deck_type} roof deck`;\n    \n    if (inputs.project_type === 'tearoff') {\n      content += `\\n\\n**Note:** All existing roof system materials will be removed down to the structural deck. Contractor shall verify all existing conditions and report any structural deficiencies to the engineer prior to installation of new roof system.`;\n    } else {\n      content += `\\n\\n**Note:** New roof system will be installed over existing roof assembly. Existing roof must be in suitable condition for recover application per manufacturer requirements.`;\n    }\n    \n    return {\n      sectionId: section.id,\n      title: 'EXISTING CONDITIONS',\n      content\n    };\n  }\n  \n  private generateNewRoofSystem(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    const membraneSpec = this.getMembraneSpecification(inputs);\n    const insulationSpec = this.getInsulationSpecification(inputs);\n    \n    let content = `**NEW ROOF SYSTEM**\\n\\n`;\n    content += `The new roof system shall consist of:\\n\\n`;\n    \n    // Insulation\n    content += `• **Insulation:** ${insulationSpec}\\n`;\n    \n    // Cover board if specified\n    if (inputs.cover_board_type) {\n      content += `• **Cover Board:** ${inputs.cover_board_type}\\n`;\n    }\n    \n    // Membrane\n    content += `• **Membrane:** ${membraneSpec}\\n`;\n    \n    // Attachment method\n    const attachmentMethod = this.getAttachmentMethod(inputs);\n    content += `• **Attachment:** ${attachmentMethod}\\n\\n`;\n    \n    // System performance\n    content += `**System Performance Requirements:**\\n`;\n    content += `• Roof assembly shall provide uplift resistance per calculated wind loads\\n`;\n    content += `• System shall be installed per manufacturer's specifications\\n`;\n    content += `• All components shall be compatible with each other\\n`;\n    \n    if (inputs.hvhz) {\n      content += `• **HVHZ Requirements:** System shall comply with High Velocity Hurricane Zone requirements\\n`;\n    }\n    \n    return {\n      sectionId: section.id,\n      title: 'NEW ROOF SYSTEM',\n      content,\n      formatting: { highlight: true }\n    };\n  }\n  \n  private generateWindUpliftRequirements(section: SelectedSection, inputs: ProjectInputs, windData?: WindPressureResult): GeneratedContent {\n    let content = `**WIND UPLIFT REQUIREMENTS**\\n\\n`;\n    \n    if (windData) {\n      content += `**Design Wind Pressures** (${windData.metadata.asceVersion}):  \\n`;\n      content += `• Zone 1 (Field): ${Math.abs(windData.windUpliftPressures.zone1Field).toFixed(1)} psf\\n`;\n      content += `• Zone 2 (Perimeter): ${Math.abs(windData.windUpliftPressures.zone2Perimeter).toFixed(1)} psf\\n`;\n      content += `• Zone 3 (Corner): ${Math.abs(windData.windUpliftPressures.zone3Corner).toFixed(1)} psf\\n\\n`;\n      \n      content += `**Design Parameters:**\\n`;\n      content += `• Basic Wind Speed: ${windData.metadata.basicWindSpeed} mph\\n`;\n      content += `• Exposure Category: ${windData.metadata.exposureCategory}\\n`;\n      content += `• Building Code: ${windData.metadata.codeCycle}\\n`;\n      \n      if (windData.metadata.hvhz) {\n        content += `• **High Velocity Hurricane Zone (HVHZ): YES**\\n`;\n        content += `• Enhanced requirements apply per Florida Building Code\\n`;\n      }\n    } else {\n      content += `Wind uplift pressures to be calculated based on:\\n`;\n      content += `• Building height: ${inputs.building_height} feet\\n`;\n      content += `• Location: ${inputs.address}\\n`;\n      content += `• Applicable building code and ASCE version\\n`;\n    }\n    \n    content += `\\n**Fastening Requirements:**\\n`;\n    content += `• Fastener spacing and penetration to be determined based on calculated wind pressures\\n`;\n    content += `• Field testing may be required to verify deck thickness and capacity\\n`;\n    content += `• Most stringent manufacturer pattern requirements shall govern\\n`;\n    \n    return {\n      sectionId: section.id,\n      title: 'WIND UPLIFT REQUIREMENTS',\n      content,\n      formatting: { highlight: true }\n    };\n  }\n  \n  private generateFasteningSpecifications(section: SelectedSection, inputs: ProjectInputs, windData?: WindPressureResult, manufacturerData?: any): GeneratedContent {\n    let content = `**FASTENING SPECIFICATIONS**\\n\\n`;\n    \n    const deckType = inputs.deck_type.toLowerCase();\n    \n    if (deckType.includes('steel')) {\n      content += `**Steel Deck Fastening:**\\n`;\n      content += `• Fasteners: Self-drilling screws with 3\" minimum plates\\n`;\n      content += `• Penetration: Minimum 3/4\" into steel deck\\n`;\n    } else if (deckType.includes('gypsum')) {\n      content += `**Gypsum Deck Installation:**\\n`;\n      content += `• Insulation: Fully adhered with approved adhesive\\n`;\n      content += `• Membrane: Fully adhered system\\n`;\n    } else if (deckType.includes('concrete')) {\n      content += `**Concrete Deck Fastening:**\\n`;\n      content += `• Fasteners: Concrete fasteners with 3\" minimum plates\\n`;\n      content += `• Penetration: Minimum 1\" into concrete deck\\n`;\n    }\n    \n    if (windData) {\n      content += `\\n**Zone-Specific Patterns:**\\n`;\n      content += `• Zone 1 (Field): Pattern TBD based on ${Math.abs(windData.windUpliftPressures.zone1Field).toFixed(1)} psf\\n`;\n      content += `• Zone 2 (Perimeter): Enhanced pattern for ${Math.abs(windData.windUpliftPressures.zone2Perimeter).toFixed(1)} psf\\n`;\n      content += `• Zone 3 (Corner): Maximum pattern for ${Math.abs(windData.windUpliftPressures.zone3Corner).toFixed(1)} psf\\n`;\n    }\n    \n    content += `\\n**Quality Assurance:**\\n`;\n    content += `• Field testing required to verify deck thickness\\n`;\n    content += `• Fastener pull-out testing may be required\\n`;\n    content += `• Installation to be verified by approved inspector\\n`;\n    \n    return {\n      sectionId: section.id,\n      title: 'FASTENING SPECIFICATIONS',\n      content\n    };\n  }\n  \n  private generateFlashingsAndAccessories(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    let content = `**FLASHINGS AND ACCESSORIES**\\n\\n`;\n    \n    // HVAC units\n    if (inputs.hvac_units > 0) {\n      content += `**HVAC Equipment (${inputs.hvac_units} units):**\\n`;\n      content += `• Remove and reset all HVAC units\\n`;\n      content += `• Install new equipment curbs with proper flashing\\n`;\n      content += `• Coordinate with mechanical contractor for reconnection\\n\\n`;\n    }\n    \n    // Penetrations\n    if (inputs.penetrations > 0) {\n      content += `**Penetrations (${inputs.penetrations} total):**\\n`;\n      content += `• Install new pipe penetration flashing\\n`;\n      content += `• Seal all penetrations with compatible sealants\\n`;\n      content += `• Install new penetration boots as required\\n\\n`;\n    }\n    \n    // Skylights\n    if (inputs.skylights > 0) {\n      content += `**Skylights (${inputs.skylights} units):**\\n`;\n      content += `• Remove and reset existing skylights\\n`;\n      content += `• Install new skylight curbs and flashing\\n`;\n      content += `• Coordinate with glazing contractor\\n\\n`;\n    }\n    \n    // Roof hatches\n    if (inputs.roof_hatches > 0) {\n      content += `**Roof Hatches (${inputs.roof_hatches} units):**\\n`;\n      content += `• Remove and reset existing hatches\\n`;\n      content += `• Install new hatch curbs with flashing\\n`;\n      content += `• Verify proper operation after installation\\n\\n`;\n    }\n    \n    // Standard flashings\n    content += `**Standard Flashings:**\\n`;\n    content += `• Perimeter edge flashing and fascia\\n`;\n    content += `• Wall flashing at vertical surfaces\\n`;\n    content += `• Expansion joint covers\\n`;\n    content += `• All flashings to be compatible with membrane system\\n`;\n    \n    return {\n      sectionId: section.id,\n      title: 'FLASHINGS AND ACCESSORIES',\n      content\n    };\n  }\n  \n  private generateDrainageSystems(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    let content = `**DRAINAGE SYSTEMS**\\n\\n`;\n    \n    if (inputs.number_of_drains > 0) {\n      content += `**Roof Drains (${inputs.number_of_drains} total):**\\n`;\n      \n      if (inputs.project_type === 'tearoff') {\n        content += `• Remove existing drains and install new\\n`;\n        content += `• Verify proper slope to drains\\n`;\n      } else {\n        content += `• Install new overflow drains as required\\n`;\n        content += `• Modify existing drains as needed\\n`;\n      }\n      \n      if (inputs.drain_types && inputs.drain_types.length > 0) {\n        content += `• Drain types: ${inputs.drain_types.join(', ')}\\n`;\n      }\n      \n      content += `• Install new drain domes and strainers\\n`;\n      content += `• Coordinate with plumbing contractor\\n\\n`;\n    }\n    \n    if (inputs.gutter_type && inputs.gutter_type !== 'None') {\n      content += `**Gutters and Downspouts:**\\n`;\n      content += `• Type: ${inputs.gutter_type}\\n`;\n      \n      if (inputs.downspouts) {\n        content += `• Downspouts: ${inputs.downspouts} locations\\n`;\n      }\n      \n      content += `• Install new gutter systems with proper slope\\n`;\n      content += `• Coordinate with building drainage requirements\\n\\n`;\n    }\n    \n    content += `**Drainage Requirements:**\\n`;\n    content += `• Minimum slope: 1/4\" per foot to drains\\n`;\n    content += `• No ponding water allowed beyond 48 hours\\n`;\n    content += `• Emergency overflow provisions required\\n`;\n    \n    return {\n      sectionId: section.id,\n      title: 'DRAINAGE SYSTEMS',\n      content\n    };\n  }\n  \n  private generateInsulationRequirements(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    const insulationSpec = this.getInsulationSpecification(inputs);\n    \n    let content = `**INSULATION REQUIREMENTS**\\n\\n`;\n    content += `**Insulation Specification:**\\n`;\n    content += `• Type: ${insulationSpec}\\n`;\n    content += `• R-Value: R-${inputs.insulation_r_value}\\n`;\n    \n    if (inputs.project_type === 'tearoff') {\n      content += `\\n**Installation:**\\n`;\n      content += `• Install new insulation over roof deck\\n`;\n      content += `• Maintain continuous thermal barrier\\n`;\n      content += `• No gaps or voids allowed\\n`;\n    } else {\n      content += `\\n**Installation:**\\n`;\n      content += `• Install new insulation over existing roof\\n`;\n      content += `• Verify compatibility with existing system\\n`;\n      content += `• Maintain proper drainage slope\\n`;\n    }\n    \n    content += `\\n**Performance Requirements:**\\n`;\n    content += `• Meet local energy code requirements\\n`;\n    content += `• Provide thermal resistance as specified\\n`;\n    content += `• Maintain properties throughout design life\\n`;\n    \n    return {\n      sectionId: section.id,\n      title: 'INSULATION REQUIREMENTS',\n      content\n    };\n  }\n  \n  private generateVaporBarrier(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    let content = `**VAPOR BARRIER**\\n\\n`;\n    \n    if (inputs.climate_zone && parseInt(inputs.climate_zone) >= 4) {\n      content += `**Vapor Barrier Required:**\\n`;\n      content += `• Climate Zone ${inputs.climate_zone} requires vapor barrier\\n`;\n      content += `• Install vapor barrier per code requirements\\n`;\n      content += `• Maintain continuous barrier with sealed joints\\n`;\n    } else {\n      content += `**Vapor Barrier Assessment:**\\n`;\n      content += `• Climate conditions reviewed\\n`;\n      content += `• Vapor barrier may not be required\\n`;\n      content += `• Verify with local code requirements\\n`;\n    }\n    \n    return {\n      sectionId: section.id,\n      title: 'VAPOR BARRIER',\n      content\n    };\n  }\n  \n  private generateWalkwayPads(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    let content = `**WALKWAY PADS**\\n\\n`;\n    \n    if (inputs.walkway_pad_requested || inputs.hvac_units > 0) {\n      content += `**Walkway Pad Installation:**\\n`;\n      content += `• Install walkway pads at high-traffic areas\\n`;\n      \n      if (inputs.hvac_units > 0) {\n        content += `• Provide access paths to HVAC equipment\\n`;\n      }\n      \n      content += `• Use manufacturer-approved pad systems\\n`;\n      content += `• Install per manufacturer specifications\\n`;\n    } else {\n      content += `**Walkway Protection:**\\n`;\n      content += `• Evaluate need for walkway protection\\n`;\n      content += `• Install as required for maintenance access\\n`;\n    }\n    \n    return {\n      sectionId: section.id,\n      title: 'WALKWAY PADS',\n      content\n    };\n  }\n  \n  private generateWarrantyAndMaintenance(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    let content = `**WARRANTY AND MAINTENANCE**\\n\\n`;\n    \n    content += `**Manufacturer Warranty:**\\n`;\n    content += `• Membrane system warranty as specified\\n`;\n    content += `• Installation warranty per manufacturer requirements\\n`;\n    content += `• Warranty registration required\\n\\n`;\n    \n    content += `**Contractor Warranty:**\\n`;\n    content += `• Workmanship warranty: 2 years minimum\\n`;\n    content += `• Materials warranty per manufacturer\\n`;\n    content += `• Callback service included\\n\\n`;\n    \n    content += `**Maintenance Requirements:**\\n`;\n    content += `• Annual roof inspections recommended\\n`;\n    content += `• Drain cleaning semi-annually\\n`;\n    content += `• Membrane cleaning as required\\n`;\n    content += `• Maintain warranty compliance\\n`;\n    \n    return {\n      sectionId: section.id,\n      title: 'WARRANTY AND MAINTENANCE',\n      content\n    };\n  }\n  \n  private generateGenericSection(section: SelectedSection, inputs: ProjectInputs): GeneratedContent {\n    return {\n      sectionId: section.id,\n      title: section.name,\n      content: `**${section.name.toUpperCase()}**\\n\\nContent for ${section.name} to be developed based on project requirements.`\n    };\n  }\n  \n  // Helper methods\n  private extractProjectName(inputs: ProjectInputs): string {\n    // Extract project name from address or use default\n    const addressParts = inputs.address.split(',');\n    return addressParts[0] || 'Roof Project';\n  }\n  \n  private buildSystemDescription(inputs: ProjectInputs): string {\n    const parts = [];\n    \n    if (inputs.insulation_type && inputs.insulation_thickness) {\n      const rValue = inputs.insulation_r_value ? ` (R-${inputs.insulation_r_value})` : '';\n      parts.push(`${inputs.insulation_thickness}\"${rValue} ${inputs.insulation_type.toLowerCase()} insulation board`);\n    }\n    \n    if (inputs.cover_board_type) {\n      parts.push(`${inputs.cover_board_type.toLowerCase()} cover board`);\n    }\n    \n    if (inputs.membrane_type && inputs.membrane_thickness) {\n      const attachmentMethod = this.getAttachmentMethod(inputs);\n      parts.push(`${attachmentMethod} ${inputs.membrane_thickness}-mil ${inputs.membrane_type} roof membrane system`);\n    }\n    \n    return parts.join(', ');\n  }\n  \n  private getMembraneSpecification(inputs: ProjectInputs): string {\n    const thickness = inputs.membrane_thickness;\n    const type = inputs.membrane_type;\n    const attachment = this.getAttachmentMethod(inputs);\n    \n    return `${attachment}, ${thickness}-mil, ${type} roof membrane system`;\n  }\n  \n  private getInsulationSpecification(inputs: ProjectInputs): string {\n    const thickness = inputs.insulation_thickness;\n    const rValue = inputs.insulation_r_value ? ` (R-${inputs.insulation_r_value})` : '';\n    const type = inputs.insulation_type;\n    \n    return `${thickness}\"${rValue} ${type} insulation board`;\n  }\n  \n  private getAttachmentMethod(inputs: ProjectInputs): string {\n    if (inputs.deck_type === 'Gypsum') {\n      return 'fully-adhered';\n    }\n    return 'mechanically attached';\n  }\n}\n\n// Factory function\nexport function createContentGenerator(): SOWContentGenerator {\n  return new SOWContentGenerator();\n}